* Comp-gen experiments

** Description

Fix a ruleset, vary the following configuration options:
- rule filtering
- phase enforcing
- new egraph for every phase
- scheduler
- syntax filtering

For each configuration, I want to measure:
- rule generation time
- compile time
- e-graph cost
- performance (simulated cycles)

Compare this against, handwritten Diospyros rules

** Emacs Play zone

Reasonable config
#+begin_src json :file (ec2/tramp "west" "test.json") :results file silent
{
    "total_node_limit": 50000000,
    "total_iter_limit": 20,
    "timeout": 240,
    "dry_run": false,
    "dump_rules": true,
    "reuse_egraphs": true,
    "cd_filter": null, 
    "require_all_vars": false,
    "phases": [
	{
	    "name": "pre-compile",
	    "cd": [null, 25.0],
	    "ca": [null, 8.0],
	    "cd_": [null, null],
	    "ca_": [null, null],
	    "node_limit": 1000000,
	    "iter_limit_": 20
	},
	{
	    "name": "compile",
	    "cd": [0.0, null],
	    "ca": [50.0, 60.0]
	},
	{
	    "name": "opt",
	    "cd": [null, null],
	    "ca": [null, null],
	    "fresh_egraph": true
	},
	{
	    "name": "all",
	    "cd": [null, null],
	    "ca": [null, null],
	    "disabled": true
	}
    ]
}
#+end_src

Wack config (that will probably work)
#+begin_src json :file filtering/test.json :results file silent
{
    "total_node_limit": 5000000,
    "total_iter_limit": 20,
    "timeout": 120,
    "dry_run": false,
    "dump_rules": false,
    "reuse_egraphs": true,
    "cd_filter": 10.0,
    "require_all_vars": true,
    "phases": [
	{
	    "name": "pre-compile",
	    "cd": [null, null],
	    "ca": [null, 10.0],
	    "node_limit": 100000,
	    "iter_limit": 10
	},
	{
	    "name": "compile",
	    "cd": [null, null],
	    "ca": [10.0, 70.0]
	},
	{
	    "name": "opt",
	    "cd": [null, null],
	    "ca": [70.0, null]
	}
    ]
}
#+end_src

Setup a remote machine
#+begin_src shell :dir (magit-toplevel) :var IP=(ec2/get-ip "west") :results output
rule_config="experiments/rule-generation/data/10-10-2108/58.json"
rsync -v $rule_config ubuntu@$IP:~/rules.json

cargo build --release --manifest-path dios-lang/Cargo.toml
rsync -v dios-lang/target/release/dios-lang \
      ~/Research/diospyros/*-params \
      ubuntu@$IP:

rsync -rv experiments/rule-generation/configs ubuntu@$IP:~/
rsync -rv experiments/rule-generation/synth_configs ubuntu@$IP:~/
#+end_src

#+RESULTS:
#+begin_example
58.json

sent 134 bytes  received 113 bytes  98.80 bytes/sec
total size is 8,491  speedup is 34.38
2d-conv-params
dios-lang
mat-mul-params
q-prod-params
qr-decomp-params

sent 26,534,938 bytes  received 33,201 bytes  10,627,255.60 bytes/sec
total size is 30,328,680  speedup is 1.14
sending incremental file list
configs/.gitignore
configs/base.json
configs/debug.json
configs/make_configs.py

sent 359 bytes  received 129 bytes  325.33 bytes/sec
total size is 2,671  speedup is 5.47
sending incremental file list
synth_configs/.gitignore
synth_configs/abs_timeout_60.json
synth_configs/abs_timeout_600.json
synth_configs/abs_timeout_6000.json
synth_configs/abs_timeout_60000.json
synth_configs/abs_timeout_600000.json
synth_configs/base.json
synth_configs/debug.json
synth_configs/make_configs.py

sent 693 bytes  received 248 bytes  627.33 bytes/sec
total size is 5,255  speedup is 5.58
#+end_example

Just send everything to the remote machine.
#+begin_src shell :dir (magit-toplevel) :var IP=(ec2/get-ip "west") :results silent
rsync -rvp --exclude='.git*' --filter="dir-merge,- .gitignore" . \
      ubuntu@$IP:
#+end_src

Look at this insidious rule: =(/ (/ ?b ?b) (- ?a 1)) -> (* (+ ?a ?a) (/ 1 ?a))=

(ite (= (* a a) 0) 0 (ite (> (* a a) 0) 1 (- 1))) != (- (div a a) (div 0 a))
(sgn (* ?a ?a)) => (- (/ ?a ?a) (/ 0 ?a))

Run things on remote machine.
#+begin_src async-shell :dir (ec2/tramp "west" "/" "home" "ubuntu") :results silent :ansi t :name "hi"
dir="experiments/rule-generation"
RUST_BACTRACE=1 RUST_LOG='debug,egg=info,ruler=info,z3=off' time \
		cargo run --release --manifest-path dios-lang/Cargo.toml \
		-- synth debug_sgn.json \
		--config $dir/configs/debug.json

# mat-mul, q-prod, 2d-conv, *qr-decomp*
# BENCH=q-prod
# RUST_LOG='debug,egg=info' time \
    # 	cargo run --release --manifest-path dios-lang/Cargo.toml -- \
    # 	compile $BENCH \
    # 	    --dios-example-bin diospyros/dios-example-gen \
    # 	    --dios-params $BENCH-params \
    # 	    --vector-width 2 \
    # 	    --rules debug_sgn.json \
    # 	    --config experiments/filtering/test.json
#+end_src

The money question is why we are using rules that are never explicitly checked by =L::is_valid=.

#+begin_src async-shell :dir (magit-toplevel) :results silent
cd dios-lang

# rsync -vP  \ samthomas@sgt.csres.utexas.edu:~/Research/comp-gen/experiments/rule-generation/data/10-10-2108/58.json 
# RUST_LOG=debug,egg=off \

systemd-run -E RUST_LOG='debug,egg=off' --scope --user -p MemoryMax=4G \
	    cargo run --release -- compile q-prod \
      --dios-example-bin ~/Research/diospyros/dios-example-gen \
      --dios-params ~/Research/diospyros/q-prod-params \
      --vector-width 2 \
      --rules ~/Research/comp-gen/experiments/rule-generation/data/10-10-2108/58.json \
      --config ../experiments/filtering/test.json

      # --pre-desugared --rules ~/Research/diospyros/t2.json \
#+end_src

Debug =sgn= ruler synthesis.
#+begin_src async-shell :dir (concat (magit-toplevel) "dios-lang") :results silent
systemd-run -E RUST_LOG="info,egg=off,ruler=info,z3=off" --scope --user -p MemoryMax=6G \
	    cargo run --release -- synth \
      ../experiments/debug_sgn.json \
      --config ../experiments/rule-generation/configs/debug.json \
      --ruler ../experiments/rule-generation/synth_configs/debug.json
#+end_src

* Aella (simple IMP-like language) experiments

** Description

Compare against handwritten rules. Show that some known, but non-trivial optimizations can be automatically generated.

* Rule Generation

** Description

Fix a set of filtering parameters, and play with the following settings:
- initial seed set
- how long we run ruler

** TODO add sqrt, and sgn to ruler generation

** Run the experiment

#+begin_src async-shell :dir rule-generation
./run.py new
./run.py setup <dir>
./run.py watch <dir>
#+end_src

** Emacs Play zone

#+begin_src emacs-lisp :results silent
(setq sgt/elisp-compile-command
      '(async-shell-command
        (format "cd %s && cargo build --release --manifest-path dios-lang/Cargo.toml && rsync -vP dios-lang/target/release/dios-lang ubuntu@%s:"
		(magit-toplevel)
		(ec2/get-ip "exp1"))))
#+end_src

#+begin_src async-shell :dir (ec2/tramp "exp1") :results silent
export RUST_LOG=info,egg=off
./dios-lang synth out.json \
	    --config configs/debug.json \
	    --ruler synth_configs/test.json
#+end_src

