* You've found the place for doing cycle estimations

I'm starting out by just trying to get a single thing working manually. I have things
setup to produce the final diospyros =kernel.c= file. I now want to setup a minimal harness to see if I can get Xtensa simulation working.

** Instructions for setting up Xtensa

You first need to download a =XtensaTools=. You can find this on the XPG site under any version number in the tools directory. Put this directory somewhere and extract it. This becomes the root directory of the Xtensa installation.

I have it set up like:
#+begin_example
xtensa/
  RI-2021.8-linux/
    XtensaTools/    # home for the all of the Xtensa utilities
    config/         # the Core Registry. Keeps configuration about what cores are installed
#+end_example

You can have other versions of the tools installed in the parent =xtensa= directory.

Next you need to install core specific configuration. These can be found on the XPG site for some version in the =reference-cores= directory. I've been using Fusion G3 because that's what Diospyros uses.

The file that you download will be an =.xws= file. This is really just a renamed zip archive. Extract it with =unzip=. This will create a =__downloads= directory. Find the core archive in this directory (it is easy to find). Extract that tar file. Inside the resulting directory is an =install= script. Run this script and pass in the location of the XtensaTools directory for the corresponding version when prompted.

That's it! Now running =xt-clang= and corresponding compilers should just "work". They'll use whatever core you have set as default. I think you can also specify the name of a particular core on the command line.

You also have to setup the license server. I honestly don't remember how I did that. You have to download the license file and then start up the license server with that file. It was relatively straightforward. I'll come back and document it next time I have to start it.

** q-prod

copy the kernel here

#+begin_src async-shell :var IP=(ec2/get-ip "exp") :results silent
rsync -e 'ssh -o StrictHostKeyChecking=no' -v \
      ubuntu@$IP:~/q-prod-out/kernel.c \
      q-prod/dios-egg-kernel.c
#+end_src

#+begin_src async-shell :results silent :ansi t :dir q-prod :name q-prod
XTENSA=~/Research/xtensa/RI-2021.8-linux/XtensaTools
XTCLANG=$XTENSA/bin/xt-clang++
XTRUN=$XTENSA/bin/xt-run

$XTCLANG -std=c++11 -O3 -LNO:SIMD -w -DXCHAL_HAVE_FUSIONG_SP_VFPU=1 -DOUTFILE='"q-prod.out"' \
	 -I /usr/include/eigen3 \
	 -I ~/Research/xtensa/fusiong3_library/include \
	 -I ~/Research/xtensa/fusiong3_library/include_private \
	 egg-kernel.c harness.c -o q-prod.o

$XTRUN --summary --mem_model q-prod.o
#+end_src

** mat-mul

I need to add these flags to the compile command
=-DA_ROWS=$(A_ROWS) -DA_COLS=$(A_COLS)=

copy the kernel here
#+begin_src shell :var IP=(ec2/get-ip "exp") :results output
rsync -e 'ssh -o StrictHostKeyChecking=no' -v \
      ubuntu@$IP:~/mat-mul-out/kernel.c \
      mat-mul/egg-kernel.c
#+end_src

#+RESULTS:
: kernel.c
: 
: sent 61 bytes  received 1,490 bytes  620.40 bytes/sec
: total size is 2,084  speedup is 1.34

This is the generated kernel:

#+begin_example
(VecMAC
  (VecMul
    (Vec (Get A 0) (Get A 0) (Get B 0) (Get B 1))
    (Vec (Get B 0) (Get B 1) (Get A 2) (Get A 2)))
  (Vec (Get A 1) (Get A 1) (Get B 2) (Get B 3))
  (Vec (Get B 2) (Get B 3) (Get A 3) (Get A 3)))
#+end_example


#+begin_src async-shell :results silent :ansi t :dir mat-mul
XTENSA=~/Research/xtensa/RI-2021.8-linux/XtensaTools
XTCLANG=$XTENSA/bin/xt-clang++
XTRUN=$XTENSA/bin/xt-run

$XTCLANG -std=c++11 -O3 -LNO:SIMD -w -DXCHAL_HAVE_FUSIONG_SP_VFPU=1 \
	 -DOUTFILE='"mat-mul.out"' \
	 -DA_ROWS='2' -DA_COLS='2' \
	 -DB_ROWS='2' -DB_COLS='2' \
	 -I /usr/include/eigen3 \
	 -I ~/Research/xtensa/fusiong3_library/include \
	 -I ~/Research/xtensa/fusiong3_library/include_private \
	 egg-kernel.c harness.c -o mat-mul.o

$XTRUN --summary --mem_model mat-mul.o
#+end_src

** 2d-conv

Copy the file over:

#+begin_src async-shell :name rsync :var IP=(ec2/get-ip "exp") :results silent
rsync -e 'ssh -o StrictHostKeyChecking=no' -v \
      ubuntu@$IP:~/2d-conv-out/kernel.c \
      2d-conv/comp-gen-kernel.c
#+end_src

Run the xtensa simulator on it.

#+begin_src async-shell :name sim :results silent :ansi t :dir 2d-conv
XTENSA=~/Research/xtensa/RI-2021.8-linux/XtensaTools
XTCLANG=$XTENSA/bin/xt-clang++
XTRUN=$XTENSA/bin/xt-run
KERNEL=comp-gen-kernel.c
# KERNEL=~/Research/diospyros/fix-backend-out/kernel.c

$XTCLANG -std=c++11 -O3 -LNO:SIMD -w -DXCHAL_HAVE_FUSIONG_SP_VFPU=1 \
	 -DOUTFILE='"2d-conv.out"' \
	 -DI_ROWS='3' -DI_COLS='3' \
	 -DF_ROWS='2' -DF_COLS='2' \
	 -I /usr/include/eigen3 \
	 -I ~/Research/xtensa/fusiong3_library/include \
	 -I ~/Research/xtensa/fusiong3_library/include_private \
	 $KERNEL harness.c -o 2d-conv.o

$XTRUN --summary --mem_model 2d-conv.o
#+end_src

** TODO qr-decomp

This benchmark is giant and takes forever to complete. Even starting the runner is incredibly slow. It seems like in the original Dios evaluation, they have a separate process for running the large memory programs and it takes upwards of 4.5 hours to complete. That's not ideal.

* Data

| Benchmark | Ruleset        | Cycles |
|-----------+----------------+--------|
| q-prod    | rules.json     |        |
| q-prod    | ruler2.json    |        |
| q-prod    | expanding.json |        |
| 2d-conv   |                |        |
| mat-mul   |                |        |
| qr-decomp |                |        |
